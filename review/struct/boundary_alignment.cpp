/************************************************************************/
// 边界对齐 
// 主要要满足下面四点
// 1、结构体的起始位置，必须是结构中对边界要求最严格的数据类型所要求的位置，
//		比如double类型的起始地址约束为8 ，在基础类型中是最大的了，
//		那如果一个结构体包含double类型，则结构体本身的起始地址要能被8整除
// 2、起始地址约束和本身的大小 在windows下，可以使用__alignof(type)来查看type类型（基础类型）的起始地址约束
// 3、如果成员也是struct union之类的类型，则整体要照顾到部分，整体要满足成员能符合起始地址约束
// 4、一个组合类型，可能需要在其后填充一些字节，以保证在分配数组之后，每个数组元素要满足起始地址约束
// 判断方法
// 步骤一：前面单元的大小必须是后面单元大小的整数倍，如果不是就补齐;
// （换言之，后一个元素的起始地址要能被其起始地址约束整除，当前元素要视情况补齐到后一个元素的起始地址,
// 而一般起始地址约束恰好是其本身的大小，所以上面的规则适用）

// 步骤二：整个结构体的大小必须是最大字节的整数倍

/************************************************************************/
#include <stdio.h>
#include <stdlib.h>

struct align1
{
	char a;
	int b;
	char c;
} sim1,sim2;

// --sim1------ ----sim2----
// a---bbbbc--- a---bbbbc---
// 上面的结构体变量中，sim1的起始地址必须能被4整除
// 成员a的起始地址也是sim1的起始地址，a占用一个字节
// 成员b的起始地址也必须能被4整除，并且要紧靠成员a。
// 所以要在a之后跳过3个字节开始存放b，那么a实际占用了4字节
// 因为成员b的大小为4个字节，所以成员c的可以紧挨着b放，
// 而其后的变量也必须对齐，所以c实际也要占用4个字节
// 所以整个sim1占用12 字节

// 更好的成员排列顺序可以优化空间

struct align2
{
	int b;
	char a;
	char c;
} sim3,sim4;

int main(){
	printf("%d\n",sizeof sim1);
	printf("%d\n",sizeof sim3);
	system("pause");
	return 0;
}




