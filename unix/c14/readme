如果一个进程或者一个线程中同时处理两个读操作或者两个写操作时，不能使用阻塞IO操作。例如
某进程需要同时从两个文件描述符读数据，这是如果使用阻塞IO，那么即使一个文件描述符已经可读，
而进程依然可能阻塞在另一个读上，使得已可读的数据得不到处理。基于此，需要借助非阻塞IO技术。

但是非阻塞IO不等于异步IO。

非阻塞IO只是数据不可读或者不可写时直接返回，用非阻塞的IO处理上面的两个读的问题
最简单的方法就是不停的遍历两个文件描述符，如果可读，则读取数据，否则立即检查另一个文件描述符是否可读
这就是最简单的轮询机制。这种方法有个问题，大部分句柄可能是不可IO的，并且一旦有一个可以IO，那么进行IO花掉的时间是不可预估的
也就是不可确定下次轮询什么时候开始


而异步IO，其实是告诉内核，当此文件描述符可读或者可写（IO）的时候，发送信号（SIGPOLL：可轮询事件）给我通知我处理
但这种方法有个问题，就是进程收到SIGPOLL信号之后，并不知道到底是哪个文件描述符可以进程IO了，依然需要对每个fd进行测试

为了解决上面两种方法的问题，系统提供了基于IO多路复用技术的一些API
select pselect poll 对应非阻塞IO

select 传递三个标识位数组，分别代表读、写、错误，如果数组中某一位设置为1，标识数组索引代表的fd可以IO
poll 类似以与select，但是传递的是pollfd类型的数组，pollfd类型的三个成员分别标识句柄fd、关心的事件events（读、写、错误），
而revents在函数返回时由内核设置，用来标识此句柄发生了些事件
上述三个函数虽然可以非阻塞的进程多描述符的读写，但这实际并不是异步的，并且不能告诉我们哪些描述符状态有变化，我们依然需要轮询所有关注的描述符

epoll 对应异步IO



非阻塞IO和异步IO是高性能并发的基础
